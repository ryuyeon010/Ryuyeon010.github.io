<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>감정 캘린더 • 한 달의 기분</title>
  <style>
    :root{
      --bg:#0b1020;
      --bg-deep:#070a16;
      --panel-bg:rgba(255,255,255,.06);
      --panel-border:rgba(255,255,255,.12);
      --panel-strong:rgba(255,255,255,.12);
      --text:#e7ecf3;
      --muted:#9fb3d2;
      --accent:#7aa7ff;
      --today:#2dd4bf;
      --selected:#60a5fa;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans KR', 'Apple SD Gothic Neo', 'Malgun Gothic', 'Helvetica Neue', Arial, sans-serif;
      background: radial-gradient(1200px 700px at 20% -10%, #192041 0%, #0b1020 60%, #070a16 100%);
      overflow:hidden;
    }

    /* Space background inspired by "space no.002" (original not reproduced) */
    .space-bg{position:fixed;inset:0;z-index:-1;pointer-events:none}
    #space-canvas{width:100%;height:100%;display:block;filter: saturate(1.05) contrast(1.02)}
    .space-gradient{position:absolute;inset:-10%;background:
      radial-gradient(55% 40% at 20% 15%, rgba(60,180,255,.18) 0%, rgba(0,0,0,0) 60%),
      radial-gradient(40% 35% at 80% 20%, rgba(247,92,172,.16) 0%, rgba(0,0,0,0) 65%),
      radial-gradient(35% 35% at 60% 75%, rgba(42,208,202,.10) 0%, rgba(0,0,0,0) 65%);
      filter: blur(22px);
      opacity:.9
    }

    .app{display:grid;grid-template-columns:280px 1fr;height:100%;gap:14px;padding:16px}

    aside{
      height:100%;
      background:var(--panel-bg);
      border:1px solid var(--panel-border);
      border-radius:16px;
      padding:14px 14px 12px 14px;
      backdrop-filter: blur(8px) saturate(1.1);
      overflow:auto;
    }

    .brand{display:flex;align-items:center;gap:10px;margin-bottom:12px}
    .logo{width:12px;height:12px;border-radius:50%;background:conic-gradient(from 0deg,#7aa7ff,#2ad0ca,#f45b9a,#7aa7ff);box-shadow:0 0 18px rgba(122,167,255,.45)}
    h1{font-size:1.1rem;letter-spacing:-.02em;margin:0}
    .subtitle{color:var(--muted);font-size:.9rem;margin-top:2px}

    .date-display{margin:10px 0 12px 0;padding:8px 10px;border-radius:12px;background:rgba(255,255,255,.04);border:1px solid var(--panel-border);display:flex;justify-content:space-between;align-items:center}
    .date-display .badge{padding:4px 8px;border-radius:10px;background:rgba(255,255,255,.06);border:1px solid var(--panel-border);color:var(--muted);font-size:.8rem}

    .emotion-list{display:grid;grid-template-columns:1fr;gap:6px;margin-top:10px}
    .chip{display:flex;align-items:center;gap:10px;padding:8px 10px;border-radius:12px;background:rgba(255,255,255,.05);border:1px solid var(--panel-border);cursor:pointer;user-select:none;transition:transform .06s ease, background .2s ease, border-color .2s ease}
    .chip:hover{transform:translateY(-1px)}
    .chip input{accent-color:var(--accent)}
    .swatch{width:14px;height:14px;border-radius:50%;border:1px solid rgba(255,255,255,.5);flex-shrink:0}

    .note{margin-top:12px;display:flex;flex-direction:column;gap:6px}
    .note label{color:var(--muted);font-size:.85rem}
    .note textarea{min-height:80px;resize:vertical;border-radius:12px;border:1px solid var(--panel-border);background:rgba(0,0,0,.25);color:var(--text);padding:10px;outline:none}

    .side-actions{display:flex;gap:8px;margin-top:10px}
    .btn{background:transparent;border:1px solid var(--panel-border);color:var(--text);padding:8px 12px;border-radius:10px;cursor:pointer;transition:background .2s,border-color .2s}
    .btn:hover{background:rgba(255,255,255,.08);border-color:rgba(255,255,255,.22)}
    .btn.primary{border-color:rgba(122,167,255,.55);background:linear-gradient(180deg, rgba(122,167,255,.18), rgba(122,167,255,.08));box-shadow:inset 0 1px 0 rgba(255,255,255,.06)}

    main{position:relative;height:100%}
    .toolbar{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
    .month-nav{display:flex;align-items:center;gap:10px}
    .month-title{font-weight:700;letter-spacing:.02em}

    .calendar{height:calc(100% - 38px);background:var(--panel-bg);border:1px solid var(--panel-border);border-radius:16px;padding:10px;backdrop-filter: blur(6px);display:grid;grid-template-rows:auto 1fr}
    .dow{display:grid;grid-template-columns:repeat(7,1fr);gap:6px;margin-bottom:6px;color:var(--muted);font-size:.85rem}
    .grid{display:grid;grid-template-columns:repeat(7,1fr);grid-auto-rows:minmax(84px,1fr);gap:6px}

    .cell{position:relative;border:1px solid var(--panel-border);background:rgba(255,255,255,.03);border-radius:12px;padding:8px;overflow:hidden;transition:border-color .15s, background .15s}
    .cell:hover{border-color:rgba(255,255,255,.22)}
    .cell.selected{outline:2px solid var(--selected);outline-offset:0}
    .cell.today{box-shadow:inset 0 0 0 2px rgba(45,212,191,.55)}
    .cell .num{font-weight:700;color:#c9d7ee}
    .cell .dots{position:absolute;left:8px;bottom:8px;display:flex;gap:6px;flex-wrap:wrap}
    .dot{width:10px;height:10px;border-radius:50%;border:1px solid rgba(255,255,255,.6);box-shadow:0 0 12px rgba(255,255,255,.15)}
    .more{font-size:.75rem;color:var(--muted)}

    .legend{margin-top:10px;color:var(--muted);font-size:.85rem}
    footer{position:absolute;right:12px;bottom:8px;font-size:12px;color:#9fb3d2;opacity:.75}

    @media (max-width: 980px){
      .app{grid-template-columns:1fr;height:auto;overflow:unset}
      body{overflow:auto}
      main{min-height:70vh}
    }
  </style>
</head>
<body>
  <div class="space-bg" aria-hidden="true">
    <canvas id="space-canvas"></canvas>
    <div class="space-gradient"></div>
  </div>

  <div class="app">
    <aside>
      <div class="brand">
        <div class="logo"></div>
        <div>
          <h1>감정 캘린더</h1>
          <div class="subtitle">좌측에서 감정을 고르고, 날짜를 눌러 기록해요.</div>
        </div>
      </div>

      <div class="date-display">
        <div id="selectedDateLabel">날짜를 선택하세요</div>
        <div class="badge" id="countBadge">0개 선택</div>
      </div>

      <div id="emotionList" class="emotion-list"></div>

      <div class="note">
        <label for="note">메모</label>
        <textarea id="note" placeholder="오늘의 기분을 한 줄로 남겨보세요"></textarea>
      </div>

      <div class="side-actions">
        <button id="save" class="btn primary">저장</button>
        <button id="clearDay" class="btn">비우기</button>
      </div>

      <div class="legend">
        일반적 연상: 행복·기쁨=노랑, 슬픔=파랑, 분노=빨강, 혐오=초록, 놀람=주황, 사랑=핑크, 평온=청록, 불안=보라, 지루함·피곤=회색 등
      </div>
    </aside>

    <main>
      <div class="toolbar">
        <div class="month-nav">
          <button id="prev" class="btn" aria-label="이전 달">◀</button>
          <div id="monthTitle" class="month-title">2025년 1월</div>
          <button id="next" class="btn" aria-label="다음 달">▶</button>
        </div>
        <div>
          <button id="todayBtn" class="btn">오늘</button>
        </div>
      </div>

      <section class="calendar" aria-label="한 달 캘린더">
        <div class="dow">
          <div>일</div>
          <div>월</div>
          <div>화</div>
          <div>수</div>
          <div>목</div>
          <div>금</div>
          <div>토</div>
        </div>
        <div id="grid" class="grid"></div>
      </section>

      <footer>영감: 유연 작가 ‘space no.002’ — 색감과 분위기만 차용했어요.</footer>
    </main>
  </div>

  <script>
    // Emotions palette (category + color)
    const EMOTIONS = [
      { key: '행복', color: '#FFD54F' },
      { key: '기쁨', color: '#FFC107' },
      { key: '사랑', color: '#F06292' },
      { key: '설렘', color: '#FF7043' },
      { key: '놀람', color: '#FF9800' },
      { key: '평온', color: '#26A69A' },
      { key: '슬픔', color: '#42A5F5' },
      { key: '외로움', color: '#5C6BC0' },
      { key: '분노', color: '#EF5350' },
      { key: '불안', color: '#7E57C2' },
      { key: '혐오', color: '#66BB6A' },
      { key: '지루함', color: '#90A4AE' },
      { key: '피곤', color: '#78909C' },
      { key: '감사', color: '#FBC02D' },
      { key: '자신감', color: '#1976D2' },
      { key: '부끄러움', color: '#F48FB1' },
      { key: '죄책감', color: '#8D6E63' },
      { key: '후회', color: '#795548' },
      { key: '스트레스', color: '#D32F2F' }
    ];

    // Elements
    const gridEl = document.getElementById('grid');
    const monthTitleEl = document.getElementById('monthTitle');
    const prevBtn = document.getElementById('prev');
    const nextBtn = document.getElementById('next');
    const todayBtn = document.getElementById('todayBtn');
    const emotionListEl = document.getElementById('emotionList');
    const selectedDateLabelEl = document.getElementById('selectedDateLabel');
    const countBadgeEl = document.getElementById('countBadge');
    const noteEl = document.getElementById('note');
    const saveBtn = document.getElementById('save');
    const clearDayBtn = document.getElementById('clearDay');

    // Canvas background
    const spaceCanvas = document.getElementById('space-canvas');
    const ctx = spaceCanvas.getContext('2d', { alpha: true });
    let canvasWidth = 0, canvasHeight = 0, dpi = 1;

    // State
    const STORAGE_KEY = 'emotion-calendar-v1';
    let currentYear, currentMonth; // month: 0-11
    let selectedDate = null; // Date or null
    let entries = {}; // { 'YYYY-MM': { 'YYYY-MM-DD': { emotions: string[], note: string } } }

    function pad2(n){ return n.toString().padStart(2,'0'); }
    function ymKey(y,m){ return `${y}-${pad2(m+1)}`; }
    function ymdKey(y,m,d){ return `${y}-${pad2(m+1)}-${pad2(d)}`; }

    function persist(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(entries)); }
    function load(){
      try{ entries = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}') || {}; }
      catch{ entries = {}; }
    }

    function getEntry(y,m,d){
      const ym = ymKey(y,m); const key = ymdKey(y,m,d);
      return entries?.[ym]?.[key] || null;
    }

    function setEntry(y,m,d,data){
      const ym = ymKey(y,m); const key = ymdKey(y,m,d);
      entries[ym] = entries[ym] || {};
      if (!data || ((data.emotions?.length||0)===0 && !data.note)) {
        if (entries[ym][key]) delete entries[ym][key];
      } else {
        entries[ym][key] = data;
      }
      // prune empty month
      if (entries[ym] && Object.keys(entries[ym]).length===0) delete entries[ym];
      persist();
    }

    function getDaysInMonth(y,m){ return new Date(y, m+1, 0).getDate(); }
    function firstDayOfMonth(y,m){ return new Date(y,m,1).getDay(); } // 0: Sun

    // Sidebar
    const selectedEmotions = new Set();

    function renderEmotionList(){
      const frag = document.createDocumentFragment();
      EMOTIONS.forEach(({ key, color }) => {
        const label = document.createElement('label');
        label.className = 'chip';
        label.title = key;

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.value = key;
        input.setAttribute('aria-label', key);

        const swatch = document.createElement('span');
        swatch.className = 'swatch';
        swatch.style.background = color;

        const text = document.createElement('span');
        text.textContent = key;

        label.appendChild(input);
        label.appendChild(swatch);
        label.appendChild(text);

        input.addEventListener('change', () => {
          if (input.checked) selectedEmotions.add(key); else selectedEmotions.delete(key);
          countBadgeEl.textContent = `${selectedEmotions.size}개 선택`;
        });

        frag.appendChild(label);
      });
      emotionListEl.appendChild(frag);
    }

    function setSidebarForDate(y,m,d){
      const entry = getEntry(y,m,d);
      selectedEmotions.clear();
      emotionListEl.querySelectorAll('input[type="checkbox"]').forEach(cb => {
        const checked = !!entry?.emotions?.includes(cb.value);
        cb.checked = checked; if (checked) selectedEmotions.add(cb.value);
      });
      countBadgeEl.textContent = `${selectedEmotions.size}개 선택`;
      noteEl.value = entry?.note || '';
      selectedDateLabelEl.textContent = `${y}년 ${m+1}월 ${d}일`;
    }

    function colorForEmotion(word){
      const found = EMOTIONS.find(e => e.key === word);
      return found ? found.color : '#ffffff';
    }

    // Calendar
    let selectedCell = null;

    function clearGrid(){
      while(gridEl.firstChild) gridEl.removeChild(gridEl.firstChild);
    }

    function renderCalendar(y,m){
      clearGrid();
      const today = new Date();
      monthTitleEl.textContent = `${y}년 ${m+1}월`;

      const days = getDaysInMonth(y,m);
      const offset = firstDayOfMonth(y,m); // 0..6

      // leading blanks
      for (let i=0;i<offset;i++){
        const blank = document.createElement('div');
        gridEl.appendChild(blank);
      }

      for (let d=1; d<=days; d++){
        const cell = document.createElement('button');
        cell.className = 'cell';
        cell.setAttribute('data-day', String(d));
        cell.setAttribute('aria-label', `${y}년 ${m+1}월 ${d}일`);

        const num = document.createElement('div');
        num.className = 'num';
        num.textContent = String(d);
        cell.appendChild(num);

        const dots = document.createElement('div');
        dots.className = 'dots';
        cell.appendChild(dots);

        const entry = getEntry(y,m,d);
        if (entry?.emotions?.length){
          const maxDots = 6;
          const unique = Array.from(new Set(entry.emotions));
          unique.slice(0, maxDots).forEach(k => {
            const dot = document.createElement('span');
            dot.className = 'dot';
            dot.style.background = colorForEmotion(k);
            dots.appendChild(dot);
          });
          if (unique.length > maxDots){
            const more = document.createElement('span');
            more.className = 'more';
            more.textContent = `+${unique.length - maxDots}`;
            dots.appendChild(more);
          }

          // subtle cell tint from first color
          const bg = colorForEmotion(unique[0]);
          cell.style.background = `linear-gradient(180deg, ${hexToRgba(bg,.18)}, rgba(255,255,255,.03))`;
        }

        if (today.getFullYear()===y && today.getMonth()===m && today.getDate()===d){
          cell.classList.add('today');
        }

        cell.addEventListener('click', () => {
          if (selectedCell) selectedCell.classList.remove('selected');
          selectedCell = cell; cell.classList.add('selected');
          selectedDate = new Date(y,m,d);
          setSidebarForDate(y,m,d);
          // visual fan-out
          const rect = cell.getBoundingClientRect();
          const cx = rect.left + rect.width/2; const cy = rect.top + rect.height/2;
          const colors = (entry?.emotions?.length ? Array.from(new Set(entry.emotions)) : ['평온']).map(colorForEmotion);
          burstAt(cx, cy, colors);
        });

        gridEl.appendChild(cell);
      }
    }

    // Month navigation
    function setMonth(y,m,opts={ selectToday:false }){
      currentYear = y; currentMonth = m;
      renderCalendar(y,m);
      if (opts.selectToday){
        const t = new Date();
        if (t.getFullYear()===y && t.getMonth()===m){
          const idx = firstDayOfMonth(y,m) + t.getDate() - 1;
          const cell = gridEl.children[idx];
          if (cell){
            cell.click();
            cell.scrollIntoView({ block:'nearest', behavior:'smooth' });
          }
        }
      }
    }

    prevBtn.addEventListener('click', () => {
      const d = new Date(currentYear, currentMonth - 1, 1);
      setMonth(d.getFullYear(), d.getMonth());
      selectedDate = null; selectedDateLabelEl.textContent = '날짜를 선택하세요';
      clearSidebarSelection();
    });
    nextBtn.addEventListener('click', () => {
      const d = new Date(currentYear, currentMonth + 1, 1);
      setMonth(d.getFullYear(), d.getMonth());
      selectedDate = null; selectedDateLabelEl.textContent = '날짜를 선택하세요';
      clearSidebarSelection();
    });
    todayBtn.addEventListener('click', () => {
      const t = new Date();
      setMonth(t.getFullYear(), t.getMonth(), { selectToday:true });
    });

    function clearSidebarSelection(){
      emotionListEl.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked=false);
      selectedEmotions.clear();
      countBadgeEl.textContent = '0개 선택';
      noteEl.value = '';
    }

    // Save / Clear
    saveBtn.addEventListener('click', () => {
      if (!selectedDate){
        alert('먼저 날짜를 선택해주세요.');
        return;
      }
      const emotions = Array.from(selectedEmotions);
      const note = noteEl.value.trim();
      setEntry(selectedDate.getFullYear(), selectedDate.getMonth(), selectedDate.getDate(), { emotions, note });
      renderCalendar(currentYear, currentMonth);

      // Success burst using chosen emotions
      const rect = selectedCell?.getBoundingClientRect();
      if (rect){
        const cx = rect.left + rect.width/2; const cy = rect.top + rect.height/2;
        const colors = (emotions.length? emotions: ['평온']).map(colorForEmotion);
        burstAt(cx, cy, colors);
      }
    });

    clearDayBtn.addEventListener('click', () => {
      if (!selectedDate) return;
      setEntry(selectedDate.getFullYear(), selectedDate.getMonth(), selectedDate.getDate(), null);
      clearSidebarSelection();
      renderCalendar(currentYear, currentMonth);
    });

    // Utilities
    function hexToRgba(hex, alpha){
      const v = hex.replace('#','');
      const r = parseInt(v.substring(0,2),16);
      const g = parseInt(v.substring(2,4),16);
      const b = parseInt(v.substring(4,6),16);
      return `rgba(${r},${g},${b},${alpha})`;
    }

    // SPACE BACKGROUND — slow-floating orbs + stars
    const stars = []; // {x,y,speed,alpha,size}
    const orbs = [];  // {x,y,baseX,baseY,radius,color,phase,speed}
    const bursts = []; // transient burst particles {x,y,vx,vy,life,color,size}

    function resizeCanvas(){
      const { clientWidth, clientHeight } = spaceCanvas;
      dpi = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvasWidth = Math.floor(clientWidth * dpi);
      canvasHeight = Math.floor(clientHeight * dpi);
      spaceCanvas.width = canvasWidth;
      spaceCanvas.height = canvasHeight;
    }

    function initSpace(){
      resizeCanvas();
      stars.length = 0; orbs.length = 0; bursts.length = 0;
      const starCount = Math.floor((canvasWidth*canvasHeight) / (130*130)); // density
      for(let i=0;i<starCount;i++){
        stars.push({
          x: Math.random()*canvasWidth,
          y: Math.random()*canvasHeight,
          speed: 0.05 + Math.random()*0.2,
          alpha: 0.35 + Math.random()*0.45,
          size: 0.6 + Math.random()*1.6
        });
      }
      const orbColors = ['#79a6ff','#2ad0ca','#f45b9a'];
      for(let i=0;i<6;i++){
        const radius = (canvasWidth+canvasHeight)/14 * (0.4 + Math.random()*0.7);
        const x = Math.random()*canvasWidth;
        const y = Math.random()*canvasHeight;
        orbs.push({
          x, y, baseX:x, baseY:y, radius,
          color: orbColors[i%orbColors.length],
          phase: Math.random()*Math.PI*2,
          speed: 0.0004 + Math.random()*0.0008
        });
      }
    }

    function burstAt(xCss, yCss, colors){
      const rect = spaceCanvas.getBoundingClientRect();
      const x = (xCss - rect.left) * dpi;
      const y = (yCss - rect.top) * dpi;
      const count = 40 + Math.floor(Math.random()*24);
      for(let i=0;i<count;i++){
        const ang = Math.random()*Math.PI*2;
        const spd = 0.6 + Math.random()*2.2;
        bursts.push({
          x, y,
          vx: Math.cos(ang)*spd,
          vy: Math.sin(ang)*spd,
          life: 1.0,
          color: colors[i % colors.length],
          size: 1 + Math.random()*2
        });
      }
    }

    function draw(){
      if (!ctx) return;
      ctx.clearRect(0,0,canvasWidth,canvasHeight);

      // subtle vignette base
      const grad = ctx.createRadialGradient(canvasWidth*0.2, canvasHeight*0.1, 50, canvasWidth*0.2, canvasHeight*0.1, Math.max(canvasWidth, canvasHeight));
      grad.addColorStop(0, 'rgba(25,32,65,.25)');
      grad.addColorStop(1, 'rgba(11,16,32,0)');
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,canvasWidth,canvasHeight);

      // orbs
      for(const o of orbs){
        o.phase += o.speed;
        o.x = o.baseX + Math.sin(o.phase*1.7) * 80 * dpi;
        o.y = o.baseY + Math.cos(o.phase*1.2) * 60 * dpi;
        const g = ctx.createRadialGradient(o.x, o.y, 0, o.x, o.y, o.radius);
        const rgba = hexToRgba(o.color, .12);
        g.addColorStop(0, hexToRgba(o.color,.18));
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(o.x, o.y, o.radius, 0, Math.PI*2);
        ctx.fill();
        ctx.globalCompositeOperation = 'lighter';
      }

      // stars
      ctx.globalCompositeOperation = 'screen';
      ctx.fillStyle = '#ffffff';
      for(const s of stars){
        s.y += s.speed * dpi;
        if (s.y > canvasHeight) { s.y = 0; s.x = Math.random()*canvasWidth; }
        ctx.globalAlpha = s.alpha * (0.6 + Math.sin((s.x+s.y)*0.002)*0.4);
        ctx.fillRect(s.x, s.y, s.size, s.size);
      }
      ctx.globalAlpha = 1;

      // bursts
      for (let i=bursts.length-1; i>=0; i--){
        const p = bursts[i];
        p.x += p.vx * 2.2 * dpi;
        p.y += p.vy * 2.2 * dpi;
        p.life -= 0.016;
        if (p.life <= 0){ bursts.splice(i,1); continue; }
        ctx.fillStyle = hexToRgba(p.color, Math.max(0, p.life));
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * dpi, 0, Math.PI*2);
        ctx.fill();
      }

      requestAnimationFrame(draw);
    }

    window.addEventListener('resize', () => { resizeCanvas(); });

    // Boot
    load();
    renderEmotionList();

    const now = new Date();
    setMonth(now.getFullYear(), now.getMonth(), { selectToday:true });

    initSpace();
    draw();
  </script>
</body>
</html>
